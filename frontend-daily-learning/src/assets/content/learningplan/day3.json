{
    "day": 3,
    "sections": [
      {
        "title": "JavaScript",
        "topic": "Scopes and Closures",
        "solution": "### üîç Scopes in JavaScript\nJavaScript has function-level and block-level scopes.\n\n```js\nfunction outer() {\n  let a = 10;\n  function inner() {\n    console.log(a); // Closure: inner 'remembers' a\n  }\n  return inner;\n}\n\nconst closureFn = outer();\nclosureFn(); // 10\n```\n\n### ‚úÖ Closure\nA closure is created when a function retains access to its parent‚Äôs scope, even after the parent function has returned."
      },
      {
        "title": "Angular",
        "topic": "Dependency Injection in Angular",
        "solution": "### üíâ What is Dependency Injection (DI)?\nAngular's DI system provides components with the dependencies (services, config, etc.) they need.\n\n```ts\n@Injectable({ providedIn: 'root' })\nexport class UserService {\n  getUser() { return 'Rajesh'; }\n}\n\n@Component({...})\nexport class ProfileComponent {\n  constructor(private userService: UserService) {}\n}\n```\n\n- `@Injectable` marks classes for DI.\n- `providedIn: 'root'` means the service is a singleton across the app."
      },
      {
        "title": "TypeScript",
        "topic": "Interfaces and Types",
        "solution": "### üß© Type vs Interface\nBoth are used for type-checking objects.\n\n```ts\ninterface User {\n  name: string;\n  age: number;\n}\n\ntype Admin = {\n  name: string;\n  accessLevel: string;\n};\n\nfunction printUser(user: User | Admin) {\n  console.log(user.name);\n}\n```\n\n- `interface` can be extended.\n- `type` can use unions, intersections.\n\n```ts\ninterface A { a: string; }\ninterface B extends A { b: number; }\n```"
      },
      {
        "title": "Frontend Architecture",
        "topic": "Component Communication Strategies",
        "solution": "### üîó Component Communication in Frontend\nIn Angular:\n\n1. **@Input / @Output** ‚Äì for parent-child\n```ts\n@Input() title: string;\n@Output() clicked = new EventEmitter<void>();\n```\n2. **Service with Subject/Observable** ‚Äì for sibling or deep tree communication\n```ts\nconst subject = new Subject<string>();\nsubject.next('Hello');\n```\n3. **State Management Tools** ‚Äì like NgRx, Signals (Angular 17+), or Akita\n\n### ü§ù Why it's important:\n- Encourages separation of concerns\n- Prevents tightly coupled components\n- Makes apps scalable"
      }
    ]
  }
  